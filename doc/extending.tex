The standard semantic annotation helpers provided by \Mimir\ are adequate for
many use cases, but if your application needs more functionality that they
cannot provide it is easy to add your own custom helper implementations using a
plugin mechanism.  This process is described in
section~\ref{sec:extend:helpers}.  Similarly, the basic \Mimir\ demo
application shows the simplest way to use the \Mimir\ Grails plugin, but it
provides no authentication or security, for example.  To add these kinds of
features you can install the \Mimir\ plugin into your own custom Grails
application, as described in section~\ref{sec:extend:customapp}.

\section{Creating new Semantic Annotation Helpers}\label{sec:extend:helpers}

{\em Semantic annotation helpers} (SAHs) are the mechanism that \Mimir\ uses to
store information about annotations and allow this information to be queried at
search time.  A SAH is associated with a particular annotation type in the
\Mimir\ index configuration, and performs two functions:

\bde
\item[During indexing] for each annotation of the relevant type, store
  information about that annotation in some persistent form and return to
  \Mimir\ one or more URIs that represent that annotation.  These URIs are
  included in the main MG4J index and associated with the location
  in the document where the annotation was found.
\item[During searching] given a set of feature value constraints, use the
  persistent store created during indexing to determine the URIs associated
  with annotations that satisfy the constraints.
\ede

Conceptually, SAH implementations can be divided into two types.
{\em Generic} helpers are those that can index any annotation types and
features, and {\em special-purpose} helpers are those that are designed to work
with specific types of annotation.  There are two generic SAH implementations
provided with \Mimir\ by default.  You would create a new generic SAH
implementation if you wanted to store annotation data in a different underlying
storage format.  \Mimir\ provides one example special-purpose SAH for
Measurement annotations, which can serve as a template for how to implement
your own helpers for other annotation types.

\subsection{The {\tt SemanticAnnotationHelper} interface}

The {\tt gate.mimir.SemanticAnnotationHelper} interface is the contract that
all helpers must implement.  It specifies three groups of methods that must be
implemented:

\subsubsection*{Lifecycle methods}

The interface includes two pairs of init/close lifecycle methods, one pair
taking an {\tt Indexer} parameter (used when the helper is indexing
annotations) and the other pair taking a {\tt QueryEngine} parameter (used when
the helper is searching).  Both the Indexer and QueryEngine provide access to
an {\tt IndexConfig} object which defines the configuration of the index,
including the location of the index files on disk, and provides a mutable
``context'' map that can be used to share objects among the various SAH objects
(for example the Sesame helper uses the context to share a single connection to
the semantic repository among all the helpers associated with the index).  The
appropriate {\tt init} method is called by \Mimir\ when the index is opened (in
whichever mode), before any other requests are passed to the helper, and the
corresponding {\tt close} method is called when the index is shut down.

\subsubsection*{Indexing methods}

When indexing annotations \Mimir\ calls the following methods:

\bde
\item[documentStart(document)] Called when the indexer starts processing a
  particular document to allow the helper to perform any per-document setup
  tasks.  This method is guaranteed to be called once per document, before any
  calls to getMentionUris.
\item[getMentionUris(annotation, length, indexer)] Called once for each
  semantic annotation of this helper's type in the document.  The helper is
  expected to use the annotation's length (in tokens) and feature values to
  determine the relevant URI or URIs that represent this annotation, and return
  them. 
\item[documentEnd()] Called after all the annotation for a particular document
  have been processed.
\ede

These methods are always called from a single thread, as long as the same 
helper object is not used for more than one annotation type.

Note that the annotation length passed to {\tt getMentionUris} is measured in
{\em tokens}, not characters.  Because \Mimir\ operates on streams of tokens,
semantic annotations that partially overlap a token will be considered by
\Mimir\ to cover the whole token.  I.e. given the hypothetical example:

\begin{minipage}{\textwidth}
\begin{verbatim}
... started on 10/05/1987 by John Smith ...
    ------- -- -- -- ---- -- ---- -----
\end{verbatim}
\end{minipage}

where tokens are represented by \verb|---|, an annotation that covers just the
``87'' would be indexed as if it covered the whole ``1987'' token.

\subsubsection*{Search methods}

The final method in the interface is {\tt getMentions(annotationType,
constraints, queryEngine)}.  This method is called by \Mimir\ when searching
for annotations, and the helper must use its stored data to determine all the
possible mention URIs that satisfy the provided constraints, and return them
along with their lengths (in tokens) as provided to {\tt getMentionUris} when
the annotations were indexed.

There is a second overloading of this method specified in the interface which
is a convenience for callers when all the constraints are simple feature value
equality constraints, but generally implementors of new SAH types can ignore
this as \Mimir\ provides an abstract base class that converts the Map form of
constraints into the more general List$<$Constraint$>$ form and calls the other
method.

The {\tt getMentions()} methods may be called from multiple threads at the same
time, so implementations should be thread-safe.

\subsection{Abstract base classes}

\Mimir\ provides an abstract class {\tt AbstractSemanticAnnotationHelper}
which, as described above, implements the Map version of {\tt getMentions} in
terms of the List$<$Constraint$>$ version, and also provides empty
implementations of {\tt documentStart} and {\tt documentEnd}.  As well as this,
it provides accessor methods to access the list of feature names of each of the
five types (nominal, integer, float, text and URI) that a particular helper
object supports.  {\tt AbstractSemanticAnnotationHelper} enjoys special support
in the \Mimir\ Grails plugin, allowing clients to determine what feature names
an index supports for each annotation type whose helper extends
{\tt AbstractSemanticAnnotationHelper}.  All the standard helper
implementations provided with \Mimir\ extend this base class.

Special-purpose helpers for particular annotation types typically operate by
mapping the features of their target annotations and/or the feature constraints
in a query into a different set of features or constraints which can then be
handled by a generic helper.  The Measurement helper described in
section~\ref{sec:extend:measurement-helper} operates in this way.  To support
this pattern, \Mimir\ provides an abstract
{\tt DelegatingSemanticAnnotationHelper} which implements all the SAH interface
methods to simply delegate to another helper instance.  Subclasses can then
override the methods as appropriate to map their features or constraints into
terms that the underlying helper can understand and then call the {\tt super}
method to pass these parameters on to the delegate.

{\tt DelegatingSemanticAnnotationHelper} extends
{\tt AbstractSemanticAnnotationHelper} so it advertises the features it
supports in the usual way.  However it is important to note that the various
\verb|get*FeatureNames| methods of the delegating helper do {\em not} call
their counterparts in the delegate, which allows a delegating helper to
advertise different features from those supported by its delegate.

\subsubsection{The SAH lifecycle}

Semantic annotation helper objects go through a specific lifecycle in \Mimir.
When creating a new index for indexing, the helpers defined for each semantic
annotation type are instantiated by calling their constructors
from the Groovy DSL (see the measurements example below).
Once instantiated, the {\tt init(Indexer)} methods of each helper in turn are
called (one after the other, in a single thread, so if you are sharing objects
among your helpers through the context you can be sure that you have exclusive
access to the context map during the call to your init method).

The actual indexing process takes place in several threads in a pipelined
manner.  When a document arrives for indexing it is first processed by the
token indexer (to index the token features), then the semantic indexers
specified by the {\tt index \{ \ldots\ \}} blocks in the DSL in turn.  Each
indexer operates in its own thread, with documents passing from one to the next
via queues.  So each document is only processed by one thread at a time but
under load you may have the token indexer dealing with document 3 at the same
time as semantic indexers are dealing with documents 2 and 1.

When indexing is complete the helpers' {\tt close(Indexer)} methods are called
(again, in sequence in one thread).  The index is now closed and the SAH
objects can be garbage collected.

The index configuration, including all the SAH objects, is serialized to XML
using XStream (\url{http://xstream.codehaus.org}). Therefore it is important to
mark as \lstinline!transient! any fields of your helper class that should not be
serialized (e.g. temporary in-memory caches, etc.).

When an index is opened for searching the XML configuration is deserialized to
re-create the helper objects, and their {\tt init(QueryEngine)} methods are
called.  Note that as with Java object serialization XStream does {\em not}
call object constructors when deserializing, so any initialization must happen
in the init method or in a {\tt readResolve} method, and not in the
constructor.

Annotation queries result in calls to the relevant helper's {\tt getMentions}
method, which has been discussed in detail above.

Finally, when the index is shut down the {\tt close(QueryEngine)} methods of
the helpers are called in sequence.

\subsection{An example special-purpose helper -- the {\tt measurements} plugin}
\label{sec:extend:measurement-helper}

The GATE {\tt Tagger\_Measurements} plugin, introduced in GATE 6.1, is able to
recognise many different kinds of measurement expressions in text.  It
normalizes the value and unit of each measurement into the SI system of
measurements and stores these values as features of the Measurement annotation.
For example, the text ``45 cm'' would be annotated with a normalized unit of
metres and a normalized value of 0.45, the text ``18 in'' would also be
normalized to metres, in this case with a normalized value of 0.4572.

The \Mimir\ {\tt measurements} plugin provides a SAH that implements the same
normalization on queries.  It processes queries for a ``virtual'' feature
called ``spec'' which represents a measurement specification in a controlled
language and converts constraints on this feature into the corresponding
constraints on the real normalized value and unit features that have been
indexed.  For example, a search for \{Measurement spec="1 to 3 feet"\} would be
treated as a query for measurements whose normalized unit is metres and whose
normalized value is between 0.3048 and 0.9144, which would match both the ``45
cm'' and ``18 in'' examples above.

\subsubsection{Configuring the Measurements SAH}

To use the measurements helper you need to first ensure that the
{\tt measurements} plugin is loaded into your \Mimir\ instance, then create an
index template that specifies the right helper for Measurement annotations.
\begin{lstlisting}[texcl]
import gate.mimir.measurements.MeasurementAnnotationHelper

// \ldots
semanticAnnotations = {
  index {
    // Measurement helper with default settings
    annotation helper:new MeasurementAnnotationHelper(
          delegateHelperType:DefaultHelper)
  }
}
\end{lstlisting}

The {\tt MeasurementAnnotationHelper} constructor takes a {\tt Map} of
parameters, which can be specified in Groovy as ``named arguments'':
\begin{lstlisting}[firstnumber=6,texcl]
    // Example of how to configure a custom ``units'' file
    annotation helper:new MeasurementAnnotationHelper(
          delegateHelperType:DefaultHelper,
          unitsFile:'resources/americanUnits.dat',
          locale:'en_US')
\end{lstlisting}

The following parameters are supported:
\bde
\item[delegateHelperType (required)] a {\tt Class} object representing the type
of generic helper that the Measurements helper should delegate to.
\item[unitsFile] the location of the {\tt units.dat} file used to configure the
  measurements parser.  If not specified, a default file provided with the
  {\tt measurements} plugin is used.  This value can be an absolute URL
  (file:/path/to/units.dat) or a relative path which will be resolved against
  the {\tt measurements} plugin directory.
\item[commonWords] the location of the common words file used by the
  measurements parser.  As with the {\tt unitsFile} parameter, if omitted a
  default file bundled with the plugin is used.
\item[locale] the locale under which the measurements will be parsed.  Defaults
  to ``en\_GB'' if unspecified.
\item[encoding] the character encoding used to read the configuration files.
  Defaults to ``UTF-8'' if unspecified.
\ede

The measurements SAH is pre-configured with the feature names that the
measurements tagger produces, and can only be used for annotations of type
{\tt Measurement}.

\subsubsection{Measurements helper implementation}

The {\tt MeasurementAnnotationHelper} extends the
{\tt DelegatingSemanticAnnotationHelper} base class described above.  It does
not add any behaviour at indexing time, simply passing all the annotations
through directly to its delegate.  However it overrides the {\tt getMentions}
search method to support the ``spec'' feature.

When a query including a spec feature constraint is received, the helper parses
this spec using the measurements parser to obtain a normalized unit and value
or values for the measurement sought.  It then constructs a number of new
constraint sets that match annotations compatible with the spec and then for
each of these alternatives, runs these constraints in combination with the
other non-spec constraints of the original query against the delegate helper.
The final set of URIs returned is the union of the results obtained from the
delegate for all the alternative reformulations of the spec constraint.

As well as being useful in its own right for Measurement annotations, the
measurements helper serves as an example of how to implement your own
special-purpose helper based on the delegating base class.  Feel free to use it
as a template for your own helper implementations.

\subsection{Packaging new helper types for use with \Mimir}

To create a new helper type and make it available to \Mimir\ you need to first
write your Java class that implements {\tt SemanticAnnotationHelper}, typically
via one of the abstract base classes.  To make your helper available to \Mimir\
requires a couple of extra steps.

Helper implementations are loaded into \Mimir\ using the standard GATE CREOLE
plugin mechanism.  The helper class or classes must be packaged up into a JAR
file which is placed in a directory containing a simple {\tt creole.xml} file.
\begin{lstlisting}[language=XML]
<CREOLE-DIRECTORY>
  <JAR>my-plugin.jar</JAR>
</CREOLE-DIRECTORY>
\end{lstlisting}

This directory is now a CREOLE plugin that can be loaded into \Mimir, for
example by using the configuration options described in
Section~\ref{sec:admin:config}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Embedding \Mimir\ in a custom Grails application}
\label{sec:extend:customapp}

The demo Grails application provided with \Mimir\ provides access to the
functionality of the \Mimir\ Grails plugin but is deliberately kept simple.  It
does not address concerns such as security and authentication, but these can be
handled by installing the \Mimir\ plugin into a custom Grails application and
adding these functions there.

\subsection{Installing the \Mimir\ plugin}

The \Mimir\ plugin is installed like any other Grails plugin, by running
{\tt grails package-plugin} in the {\tt grails-plugin-mimir} directory to
create a plugin zip file and then
{\tt grails install-plugin grails-mimir-web-\{version\}.zip} in your
application's base directory to install the plugin into your application.  On
installation the plugin adds a number of files to the host application:

\bde
\item[grails-app/conf/MimirConfig.groovy] a default configuration file for
  \Mimir\ settings, which can be customised as described in
  section~\ref{sec:admin:config}.
\item[grails-app/conf/MimirUrlMappings.groovy] a default set of URL mappings
  for \Mimir\ controllers.  These are discussed in more detail below.
\item[web-app/WEB-INF/gate-home] a default GATE home directory, containing user
  and site configuration files and the default query tokeniser application, as
  required by the template configuration file.
\ede

\subsection{URL mappings}

The standard URL mappings for \Mimir\ adhere to the following conventions:
\bit
  \item All administrative actions have URLs that start with {\tt /admin}. This
  is intended to simplify the job of providing security via an external
  mechanism, such as the default container-provided security defined by the
  servlet specification.
  \item The URLs for all actions referring to a given index have a common prefix
  (by default {\tt /\{indexId\}/}). This is used to support remote access
  through the {\tt mimir-client} library, which relies on a base URL to which it
  adds known suffixes to access given functionality (e.g. the search actions
  are all found under {\tt /\{indexId\}/search/\{actionName\}}). The
  mimir-client library is used, for example, in the implemenation of remote
  indexes.
\eit

These default mappings may be modified, but the protocols used by client
code to push documents into an index, to search using the XML API, and to
interact with remote indexes all make assumptions about certain relative paths.
Therefore, if you need to allow remote access via the {\tt mimir-client}
library, then you must make sure that:

\bit
\item there is a URL prefix that is common to all actions provided by the
  {\tt IndexManagementController} and the {\tt SearchController}. Let us call
  this common prefix the {\tt \{indexUrl\}};
\item all actions provided by the {\tt IndexManagementController} should be
  published under {\tt \{indexUrl\}/manage/\{actionName\}};
\item all actions provided by the {\tt SearchController} should be
  published under {\tt \{indexUrl\}/search/\{actionName\}};
\item all actions of the search controller must have {\tt parseRequest:true}; 
\item the names of the actions in the controllers above must not be changed.
\eit 

\subsection{Security considerations}

There are a number of established and mature Grails plugins that implement user
registration, authentication and security in various ways for Grails
applications.  By design, the \Mimir\ plugin and demo app do not provide any
security of their own, but for production deployments you may wish to consider
any or all of the following.

\begin{itemize}
\item Place your application behind an Apache HTTPD or other similar front-end
  server, and proxy only those URLs that need to be public (/css, /gwt,
  /images, /plugins, /\{yourindex\}/search, etc.)
\item Install a security plugin such as spring-security-core or nimble, and
  restrict the \Mimir\ pages to certain users.  For example the /admin pages
  could be restricted to administrative users, the gus pages to registered
  searchers, etc.
\item If your \Mimir\ instance is a slave in a federated index, use firewall
  rules or a Grails filter to restrict access to the */search URLs to only the
  master \Mimir\ server.
\end{itemize}

Note that if you use user authentication on the XML search API or the remote
protocol then you will need to modify the default client code to authenticate
itself appropriately.  For example if you require HTTP basic authentication for
the search or manage URLs then you will need to configure the master \Mimir\
server that uses this as a remote to make it pass the relevant Authorization
HTTP header.  The remote protocol uses the {\tt WebUtils} class in
{\tt mimir-client} to make its HTTP calls, and there is a subclass of this
class that is able to provide basic authentication headers, you can wire this
in by overriding the definition of the webUtilsManager Spring bean supplied by
the \Mimir\ plugin -- see the plugin source code for full details.
